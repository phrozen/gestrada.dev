<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=author content="Guillermo Estrada"><meta name=description content="Hello blog! Introduction to p5.js and cellular automata with Conway's Game of Life"><meta name=keywords content="dev,blog,developer,golang,js,algorithms,generative art"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1530328411047-7063dbd29029?crop=entropy&cs=srgb&fm=jpg&ixid=MXwyMTAzMTZ8MHwxfGFsbHx8fHx8fHx8&ixlib=rb-1.2.1&q=80&fit=crop&w=1200h=627"><meta name=twitter:title content="The Game of Life"><meta name=twitter:description content="Hello blog! Introduction to p5.js and cellular automata with Conway's Game of Life"><meta property="og:title" content="The Game of Life"><meta property="og:description" content="Hello blog! Introduction to p5.js and cellular automata with Conway's Game of Life"><meta property="og:type" content="article"><meta property="og:url" content="https://gestrada.dev/posts/the-game-of-life/"><meta property="og:image" content="https://images.unsplash.com/photo-1530328411047-7063dbd29029?crop=entropy&cs=srgb&fm=jpg&ixid=MXwyMTAzMTZ8MHwxfGFsbHx8fHx8fHx8&ixlib=rb-1.2.1&q=80&fit=crop&w=1200h=627"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-18T00:00:00+00:00"><title>The Game of Life ¬∑ gestrada.dev</title><link rel=canonical href=https://gestrada.dev/posts/the-game-of-life/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.abe8b6775d85a01169c10329309df501aa8a008ab354002f7858f077cae76020.css integrity="sha256-q+i2d12FoBFpwQMpMJ31AaqKAIqzVAAveFjwd8rnYCA=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.89c82b6022b96f77aeb521b240daec4f87ea029d84d1c78b8acd0735b91b3c92.css integrity="sha256-icgrYCK5b3eutSGyQNrsT4fqAp2E0ceLis0HNbkbPJI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/style.min.4064da43b12fed7ce090aad600343e56e27611675030ebe1cdfe7e0200528d78.css integrity="sha256-QGTaQ7Ev7XzgkKrWADQ+VuJ2EWdQMOvhzf5+AgBSjXg=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><script defer src=https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js integrity=sha384-5f4X0lBluNY/Ib4VhGx0Pf6iDCF99VGXJIyYy7dDLY5QlEd7Ap0hICSSZA1XYbc4 crossorigin=anonymous></script><meta name=generator content="Hugo 0.81.0"></head><body class=colorscheme-auto onload=twemoji.parse(document.body)><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>gestrada.dev</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://gestrada.dev/posts/the-game-of-life/>The Game of Life</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2021-02-18T00:00:00Z>February 18, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>19-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i><a href=/categories/p5.js/>p5.js</a></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i><a href=/tags/p5.js/>p5.js</a>
<span class=separator>‚Ä¢</span>
<a href=/tags/generative-art/>generative art</a>
<span class=separator>‚Ä¢</span>
<a href=/tags/automaton/>automaton</a></div></div></header><div><div class=cover><img class=cover src="https://images.unsplash.com/photo-1530328411047-7063dbd29029?crop=entropy&cs=srgb&fm=jpg&ixid=MXwyMTAzMTZ8MHwxfGFsbHx8fHx8fHx8&ixlib=rb-1.2.1&q=85&fit=clip&h=700" title="Game of life close-up" alt="white and blue car toy on top of orange game board"><p>Photo from <a href=https://unsplash.com/photos/KJMz5Tmbw0k target=_blank>Unsplash</a>
by <a href=https://unsplash.com/@randyfath target=_blank>Randy Fath</a></p><hr></div><p>Finally! I have been trying to start a dev blog for like 10 years now, and I always found a way to procrastinate that üò©.
I always thought I would never have the time or enough content to publish, and with how fast technology becomes outdated, it seemed inappropriate at the time. On the other hand, I always have been an enthusiast of generative artwork or algorithmic art, and I thought: &ldquo;Hey, that never goes old!&rdquo;, so this time around at least I got to the blog creation part, the first post and a path to learn a lot.</p><p>Usually the first thing you do when you start something technology related, has to be a <em>Hello World</em> of some sort. I enjoy writing Go or Javascript code, so I would love to just do something like&mldr;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello Blog!&#34;</span>)
}
</code></pre></div><p>&mldr; and be done with it!</p><p>But this time, I would like to do something related to generative art, as this blog is going to track all the progress and projects I do regarding that adventure (among any other dev related stuff here and there). For that purpose, an appropriate first project was necessary, and after very little deliberation, what a better place to start than with <em>Conway&rsquo;s The Game of Life</em>! It is sort of the <em>Hello World</em> of generative art after all. (isn&rsquo;t it? üòÖ)</p><h4 id=introduction>Introduction
<a class=heading-link href=#introduction><i class="fa fa-link" aria-hidden=true></i></a></h4><p>For those of us who thought <em>The Game of Life</em> or just <em>Life</em> for short, was an <a href=https://en.wikipedia.org/wiki/The_Game_of_Life>old family board game created by Milton Bradley</a>, we need a little bit more of an introduction to <em>Conway&rsquo;s Game of Life</em>, so directly from it&rsquo;s <a href=https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life>Wikipedia article</a>:</p><blockquote><p>The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. One interacts with the Game of Life by creating an initial configuration and observing how it evolves. It is Turing complete and can simulate a universal constructor or any other Turing machine.</p></blockquote><p>This is really interesting, and it seems easy to implement and a lot of fun to play with once you have a little more information about the algorithm. It also produces very good looking results and you can tweak the implementation in a lot of ways to produce more artistic animations, all through code! üòÅ So, where to start? Let&rsquo;s keep reading:</p><blockquote><p>The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead, (or populated and unpopulated, respectively). Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent.</p></blockquote><p>So, once we start talking about two-dimension orthogonal grids, it immediately comes to mind a way to implement it using arrays, and although we cannot make an infinite grid using arrays, we can simulate the <em>infinity</em> by wrapping the borders toroidally (just like Pac-Man ‚ç©‚Éù would go out on one side of the screen and appear on the opposite side). Or we can <em>clamp</em> our grid to a finite size, just as if we are looking at a sample of this infinite world. Each of these discrete cells can only be in 2 states (alive | dead), so making a <code>boolean</code> array makes the most sense, but the question is: How do we play? How do we decide who lives and who dies?</p><p>In <em>Conway&rsquo;s Game of Life</em>, we determine the initial state of the grid, either by manually setting some cells to be alive arbitrarily or we can do so randomly. Doing it randomly seems to be the better approach, that way we can <em>&ldquo;play&rdquo;</em> with the initial state and we will get a different <em>&ldquo;game&rdquo;</em> every time. It is worth noting that there is no such thing as <em>random</em> in computers, we only have <em>pseudo-random number generators</em>, and that could potentially be good, because if we seed our generator, we can reproduce the exact same game by just using the same seed as an input. Once the initial state is set, we have to iterate through our grid and decide who lives and who dies into the next generation. We do so by following the rules set by Conway:</p><blockquote><p>At each step in time, the following transitions occur:</p><ol><li>Any live cell with fewer than two live neighbours dies, as if by under-population.</li><li>Any live cell with two or three live neighbours lives on to the next generation.</li><li>Any live cell with more than three live neighbours dies, as if by over-population.</li><li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</li></ol></blockquote><p>That seems simple enough, to implement this we have to maintain two states, the current generation and the next generation, and we can reuse both states by swapping them in each time step. To calculate the next generation state we have to iterate over the current one, and for each cell, check all it&rsquo;s neighbours and get a count of how many are alive, then proceed to seed the next generation based on these rules. After that, the next generation becomes the current generation and we start all over again. Let&rsquo;s do this!</p><p>There are hundreds of implementations of <em>Conway&rsquo;s Game of Life</em> all over the internet, there is even one for the console in the <a href=https://golang.org/doc/play/life.go>Go documentation</a> and of course there is another one in the <a href=https://p5js.org/examples/simulate-game-of-life.html>p5.js examples</a>, so let&rsquo;s try something different. This time let&rsquo;s work with 1D arrays! One dimensional arrays (or just arrays as we know them) are usually used in computer graphics to represent images, frame buffers and all kinds of two dimensional matrices. The reason is, there is no concept of 2D arrays for computers, those are just mathematical constructs on top of arbitrary data on any length. Usually the most resource intensive part of any graphics sketch is the rendering, and 2D arrays are not very optimal because we have to iterate over them and set each pixel 1 by 1 (or 1 row at a time), but with 1D arrays we could set the whole pixel data in a single assignment if we plan for it!</p><h4 id=writing-some-code>Writing some code
<a class=heading-link href=#writing-some-code><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Let&rsquo;s not get ahead of ourselves and start coding something. We&rsquo;re going to be using <a href=https://p5js.org/>p5.js</a> for this very simple example of life. From their site:</p><blockquote><p>p5.js is a JavaScript library for creative coding, with a focus on making coding accessible and inclusive for artists, designers, educators, beginners, and anyone else! p5.js is free and open-source because we believe software, and the tools to learn it, should be accessible to everyone.</p></blockquote><p>Every sketch starts the same, with 2 required functions <code>setup</code> and <code>draw</code>, aside from that, everything else is just plain old javascript and everything is fair game, let&rsquo;s start by doing our <code>setup</code> and have some arrays to store the state of our cells.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>size</span>;             <span style=color:#75715e>// simplify code
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>next</span>;      <span style=color:#75715e>// current and next generation
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>live</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>;       <span style=color:#75715e>// color for live cells
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dead</span> <span style=color:#f92672>=</span>   <span style=color:#ae81ff>0</span>;       <span style=color:#75715e>// color for dead cells
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
  <span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>180</span>, <span style=color:#ae81ff>120</span>);
  <span style=color:#a6e22e>size</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>height</span>;
  <span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> Array(<span style=color:#a6e22e>size</span>).<span style=color:#a6e22e>fill</span>(<span style=color:#a6e22e>dead</span>);
  <span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> Array(<span style=color:#a6e22e>size</span>).<span style=color:#a6e22e>fill</span>(<span style=color:#a6e22e>dead</span>);
}
</code></pre></div><p>Instead of using boolean arrays already, let&rsquo;s start by using integers and define the actual value of the color of dead or live cells, in this case <code>255</code> or white for live ones, and <code>0</code> or black for dead ones. This also has the nice side effect that 0 evaluates to false in javascript, but declaring them in a variable will make the code a lot more readable and will let us change colors later on if we want to. We also declared <code>size</code> as a shortcut for <code>width * height</code>, it will save a lot of calculations in the long run, but it&rsquo;s mainly for cleaner code too. We create our state arrays of length <code>size</code> and fill them with <code>dead</code> cells. We will be going back and forth between 1D and 2D coordinates, so let&rsquo;s review the conversions:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// From 2D(x, y) to 1D(i)
</span><span style=color:#75715e></span><span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>y</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>x</span>

<span style=color:#75715e>// From 1D(i) to 2D(x, y)
</span><span style=color:#75715e></span><span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>i</span> <span style=color:#f92672>%</span> <span style=color:#a6e22e>width</span>
<span style=color:#a6e22e>y</span> = <span style=color:#a6e22e>i</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>width</span>
</code></pre></div><p>In a 1D array, we store each row(y) of pixels one after the other, so we need to always use the width to know when each of those rows end and the next one begins. Conversions are very straightforward, but it&rsquo;s worth noting that depending on the language and platform, one has to be careful that <code>y</code> might be a floating point number, and we can only index arrays with <code>integer</code> numbers, so let&rsquo;s be careful and move on. One thing to note about 1D arrays, is that they are already toroidally bound (of sorts üòÖ) on the x axis! That means that for <code>x == width</code> if we do <code>x + 1</code>, what usually would be an <code>out of bounds</code> error on 2D arrays, in a 1D array, we just get the first item of the next row (on the other side of the screen). Not perfect but it will be good enough for this use case, we will bound the y axis later on too.</p><p>The next step would be seeding our initial state with random live cells. In a 2D array we could simply iterate over it and randomly set the cell state, but this will always give us approximately 50% of live/dead cells each time (just like flipping a coin). With 1D arrays on the other hand, we can define a percentage of live cells to seed our initial state, then generate that percentage of random numbers between <code>0</code> and <code>size</code> and use them as index to set those cells to a live state. Definitely faster, simpler and more flexible. Declare our <code>percentage</code> at the top and create our seed function.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// Randomly seeds the state with live cells
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>seed</span>() {
  <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>fill</span>(<span style=color:#a6e22e>dead</span>);
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>living</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>size</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>percentage</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>100</span>);
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>living</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
    <span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>random</span>(<span style=color:#a6e22e>size</span>))] <span style=color:#f92672>=</span> <span style=color:#a6e22e>live</span>;
  }
}
</code></pre></div><p>We make sure the state is filled with dead cells before seeding just in case we want to re-seed mid game (restart). As we can see, seeding a <code>%</code> of the state with live cells is way easier in 1D arrays. Quick note, the <code>random()</code> function in p5.js has many modes. When called with a single parameter, it will produce a number between <code>0</code> (inclusive) and that number (exclusive), but this number is a <code>float</code>, so we need to round it down to use as an index.</p><p>Next, just add a <code>seed()</code> call at the end of our setup, and we are ready to draw our cells into the canvas to see that we seeded correctly. Let&rsquo;s write our draw function next, in will also be very simple thanks to our decisions so far.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// Main rendering loop
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
    <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>%</span> <span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>color</span>(<span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span>]));
  }
  <span style=color:#a6e22e>updatePixels</span>();
  <span style=color:#75715e>// step(); // Here we will create the next generation
</span><span style=color:#75715e></span>}
</code></pre></div><p>That&rsquo;s it! Single loop and single call to set the color of the cell based on our current state. The <code>set(x, y, color)</code> function is very easy to use. We just transform our 1D coordinates into 2D inline and we don&rsquo;t even have to fix <code>y</code> because the the canvas does not care, it can take floating numbers as coordinates and will just interpolate the best possible way. One thing to note here is that we must call <code>updatePixels()</code> once we are done setting our pixel data so that it renders the whole screen again. Finally we are using the <code>color()</code> function, which also has a lot of modes, so make sure to <a href=https://p5js.org/reference/#/p5/color>check it out</a> so we can just change our colors later on.</p><p>Last but not least, our <code>step()</code> function, here is where the magic happens, we iterate through our current state, apply Conway&rsquo;s rules and create a new generation of cells. We will do this over and over, and this will be <em><em>The Game of Life!</em></em> Before we proceed, let&rsquo;s review how do we access neighbours in a 1D array, as it might not be that intuitive after all. We need to check the status of all 8 adjacent cells to find out what to do with our current cell.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// These are really simple and straight forward
</span><span style=color:#75715e></span><span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]            <span style=color:#75715e>// west
</span><span style=color:#75715e></span><span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]            <span style=color:#75715e>// east
</span><span style=color:#75715e>// If we go one width back, we are actually moving &#39;up&#39;
</span><span style=color:#75715e>// a row, same goes for down, we add a width...
</span><span style=color:#75715e></span><span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>width</span>]        <span style=color:#75715e>// north 
</span><span style=color:#75715e></span><span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>width</span>]        <span style=color:#75715e>// south
</span><span style=color:#75715e>// The rest is just a simple combination of all of them
</span><span style=color:#75715e></span><span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]    <span style=color:#75715e>// northwest
</span><span style=color:#75715e></span><span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]    <span style=color:#75715e>// northeast
</span><span style=color:#75715e></span><span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]    <span style=color:#75715e>// southwest
</span><span style=color:#75715e></span><span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]    <span style=color:#75715e>// southeast
</span></code></pre></div><p>From the code above we can see that for each <code>offset</code> only <code>i</code> is a variable, and we can treat the rest as a constant, let&rsquo;s optimize here and calculate the constant part and put them in an array so we can iterate over those faster later on. Declare <code>offsets</code> at the top and initialize it inside <code>setup</code> once the <code>width</code> is known.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>offset</span> <span style=color:#f92672>=</span> [      <span style=color:#75715e>// offsets for neighbours in 1D array
</span><span style=color:#75715e></span>    <span style=color:#f92672>-</span><span style=color:#a6e22e>width</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#75715e>// nw
</span><span style=color:#75715e></span>    <span style=color:#f92672>-</span><span style=color:#a6e22e>width</span>,     <span style=color:#75715e>// n
</span><span style=color:#75715e></span>    <span style=color:#f92672>-</span><span style=color:#a6e22e>width</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#75715e>// ne
</span><span style=color:#75715e></span>    <span style=color:#ae81ff>1</span>,          <span style=color:#75715e>// e
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>width</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,  <span style=color:#75715e>// se
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>width</span>,      <span style=color:#75715e>// s
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>width</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,  <span style=color:#75715e>// sw
</span><span style=color:#75715e></span>    <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,         <span style=color:#75715e>// w
</span><span style=color:#75715e></span>];
</code></pre></div><p>One last thing before we proceed with <code>step()</code>, let&rsquo;s do a helper function <code>at(i)</code> that will tell us if the cell is <em>dead or alive</em> for any given position in the current state, and while we are at it, let&rsquo;s bound the <code>y</code> axis toroidally altogether.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// Gets cell &#39;status&#39; at a given index (1D)
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>at</span>(<span style=color:#a6e22e>i</span>) {
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>) <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>size</span>;
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>i</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>size</span>) <span style=color:#a6e22e>i</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>size</span>;
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>live</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>What is happening here? As we only care about two bounds, if <code>index &lt; 0</code> we add <code>size</code> to it essentially moving the index to the last row <code>y</code> in the same <code>x</code> position. Comparable to that, if <code>index > size</code> we move it to the first row <code>y</code> by subtracting <code>size</code> from it. We then return <code>0</code> if it&rsquo;s dead or <code>1</code> if it&rsquo;s live, as we do not care about the actual color value of the state, but just the status for calculating the number of neighbours. Now, for the last part&mldr;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// Creates the next generation of cells
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>step</span>() {
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>neighbours</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>offset</span>) {
      <span style=color:#a6e22e>neighbours</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>at</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>j</span>);
    }
    <span style=color:#66d9ef>if</span>      ((<span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>live</span>) <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>neighbours</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>))  <span style=color:#a6e22e>next</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>dead</span>;      <span style=color:#75715e>// under-population
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((<span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>live</span>) <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>neighbours</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>))  <span style=color:#a6e22e>next</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>dead</span>;      <span style=color:#75715e>// over-population
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((<span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>dead</span>) <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>neighbours</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>)) <span style=color:#a6e22e>next</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>live</span>;      <span style=color:#75715e>// reproduction
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span>                                              <span style=color:#a6e22e>next</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span>];  <span style=color:#75715e>// stasis
</span><span style=color:#75715e></span>  }
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tmp</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>state</span>; <span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>next</span>; <span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tmp</span>;
}
</code></pre></div><p>The code is weirdly formatted on purpose for readability. As said before, we iterate over each cell and for each one, we count the number of live neighbours it has (that is why <code>at(i)</code> returns 0 or 1) by iterating over our <code>offset</code> array defined above. After that we follow Conway&rsquo;s rules to determine what the status of that cell will be towards the next generation. This could be simplified a bit further between the first and second checks (over and under population), but I think it&rsquo;s a bit more explicit what is happening this way. Finally we swap our current generation (<code>state</code>) with the next generation. Let&rsquo;s give it a try, shall we?</p><div class=sketch><div class=sketch-toolbar><div class=sketch-title><span><i class="fa fa-fw fa-chevron-right" aria-hidden=true></i>&nbsp;Simple Life</span></div><div class=sketch-controls><a class=controls href=https://github.com/phrozen/gestrada.dev/blob/main/content/posts/the-game-of-life/simple-life.js target=_blank><i class="fa fa-fw fa-code" aria-hidden=true></i></a><a class=controls href=/sketches/simple-life target=_blank><i class="fa fa-fw fa-external-link" aria-hidden=true></i></a><a class=controls onclick='reload("p5-simple-life")'><i class="fa fa-fw fa-refresh" aria-hidden=true></i></a></div></div><div class=sketch-container><iframe id=p5-simple-life class=sketch-iframe sandbox="allow-scripts allow-same-origin" srcdoc="
  <!DOCTYPE html>
<html>
    <head>
        <style>
            html, body {
                width: 100%;
                border: 0;
                padding: 0;
                margin: 0;
            }
            main, .p5Canvas {
                width: 100% !important;
                height: auto !important;
                max-width: 860px;
                display: block;
                image-rendering: pixelated;
            }
        </style>
        <script src=&#34;https://cdn.jsdelivr.net/npm/p5@latest/lib/p5.min.js&#34;></script>
    </head>
    <body>
        <script>
            
    let size;               // width * height (DRY)
let state, next;        // current and next generation
let percentage = 25;    // ~% of live cells to seed
let live = 255;         // color for live cells ('limegreen', '#FF6600')
let dead = 0;           // color for dead cells ('pink', 'rgba(123,45,67)')
let offset;             // hold the adjacent offsets of neighbours

function setup() {
    createCanvas(180, 120);
    frameRate(10);
    size = width * height;
    state = Array(size).fill(dead);
    next = Array(size).fill(dead);
    offset = [ // offsets for neighbours in 1D array
        -width - 1, // nw
        -width,     // n
        -width + 1, // ne
        1,          // e
        width + 1,  // se
        width,      // s
        width - 1,  // sw
        -1,         // w
    ];
    seed();
}

// Main rendering loop
function draw() {
    for (let i = 0; i < size; i++) {
        set(i % width, i / width, color(state[i]));
    }
    updatePixels();
    step();
}

// Randomly seeds the state with live cells
function seed() {
    state.fill(dead);
    const living = floor(size * percentage / 100);
    for (let i = 0; i < living; i++) {
        state[floor(random(size))] = live;
    }
}

// Creates the next generation of cells
function step() {
    for (let i = 0; i < size; i++) {
        let neighbours = 0;
        for (let j of offset) {
            neighbours += at(i + j);
        }
        if ((state[i] == live)      && (neighbours < 2))  next[i] = dead;     // under-population
        else if ((state[i] == live) && (neighbours > 3))  next[i] = dead;     // over-population
        else if ((state[i] == dead) && (neighbours == 3)) next[i] = live;     // reproduction
        else                                              next[i] = state[i]; // stasis
    }
    let tmp = state;
    state = next;
    next = tmp;
}

// Gets cell 'status' at a given index (1D)
function at(i) {
    if (i < 0) i += size;
    if (i > size) i -= size;
    return state[i] == live ? 1 : 0;
}

function mousePressed() {
    seed();
}
  
        </script>
    </body>
</html>
" onload=resize(this) scrolling=no frameborder=0></iframe></div></div><p>Great! üòÅ The initial state is randomly seeded with 25% live cells, and then we let the game follow it&rsquo;s course. But there is no fun in just watching it a single time, so you can click on
<i class="fa fa-fw fa-refresh accent" aria-hidden=true></i>or anywhere on the canvas to re-seed the state and restart the game. This usually runs much faster, specially for the canvas size we picked as it&rsquo;s very small, but I used <code>frameRate(10)</code> in our setup so that each step in time could be appreciated. You can click on
<i class="fa fa-fw fa-code accent" aria-hidden=true></i>on the sketch toolbar to check the code in Github. If you try this code in the <a href=https://editor.p5js.org/>p5.js web editor</a>, you will notice that the sketch is really small, exactly the way we defined it in the <code>setup</code> with <code>createCanvas(180, 120)</code>, as we are actually using pixels! Your first impulse would be to change the size and make the canvas bigger, but that will not scale the pixels, you are just going to have a lot more cells to deal with. That is why most people implement <em>The Game of Life</em> by drawing squares or so, but the trick here, is that the browser already has the ability to scale the <code>canvas</code> element regardless of it&rsquo;s size! So while embedding sketches in my blog I&rsquo;m using&mldr;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=color:#f92672>main</span><span style=color:#f92672>,</span> .<span style=color:#a6e22e>p5Canvas</span> {
    <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#75715e>!important</span>;
    <span style=color:#66d9ef>height</span>: <span style=color:#66d9ef>auto</span> <span style=color:#75715e>!important</span>;
    <span style=color:#66d9ef>max-width</span>: <span style=color:#ae81ff>860</span><span style=color:#66d9ef>px</span>;
    <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>block</span>;
    image-rendering: <span style=color:#66d9ef>pixelated</span>;
}
</code></pre></div><p>&mldr; essentially overriding p5.js style and making the canvas scale to the content, it also makes it responsive if we also scale the <code>iframe</code> (try resizing the browser). Neat! One attribute is apparently not supported in
<i class="fa fa-fw fa-firefox accent" aria-hidden=true></i>Firefox (at the time of writing) and that is <code>image-rendering: pixelated</code>. What it does, is essentially disabling interpolation while scaling our canvas, so our little pixels don&rsquo;t blur out and look like perfect squares when scaled up! You can read all about it in the <a href=https://developer.mozilla.org/es/docs/Web/CSS/image-rendering>MDN Web Docs</a>.</p><p>But, what if we wanted to implement it in a large canvas with colors and figures like everyone else? This is about generative art after all. There is not much art in diminutive black and white pixels dancing around a canvas (or&mldr; is there? ü§î). Thankfully the way we implemented this version makes it incredibly easy to play and create different versions of the game. Let&rsquo;s start by doing some changes in our setup and variables. I will only show the meaningful changes, as always the full code is available on Github.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>live</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;      <span style=color:#75715e>// Use booleans as we don&#39;t need to store
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dead</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;     <span style=color:#75715e>// the color, it&#39;s calculated on draw
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>resolution</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;  <span style=color:#75715e>// To create a virtual grid on top the canvas
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
  <span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>1280</span>, <span style=color:#ae81ff>720</span>);
  <span style=color:#a6e22e>noStroke</span>();         <span style=color:#75715e>// disables the stroke when figure drawing
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>width</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>resolution</span>;
  <span style=color:#a6e22e>height</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>height</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>resolution</span>;
  <span style=color:#a6e22e>size</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>height</span>;
  ...
}
</code></pre></div><p>So first we grow the canvas to a comfortable viewing size, and we define a <code>resolution</code> to &ldquo;scale down&rdquo; our grid, in this example our <code>state</code> of cells will be of <code>128 * 72</code>, which is a good enough grid to play with. Then as we will not be using the <code>state</code> to store the color anymore, we just change dead and live to <code>booleans</code> as originally intended (yes, the rest of the code will work without a hitch). <code>noStroke()</code> disables the stroke when figure drawing, as we will be using those now. After that, we redefine our <code>width</code> and <code>height</code> values to those scaled by our resolution, this will not change tha canvas already created, but now our whole sketch will use these. Finally let&rsquo;s modify our <code>draw</code> function and have a little fun with it.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// Main rendering loop
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
  <span style=color:#a6e22e>clear</span>();
  <span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>0</span>);
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>live</span>) {
      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>i</span> <span style=color:#f92672>%</span> <span style=color:#a6e22e>width</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>resolution</span>;
      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>i</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>width</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>resolution</span>;
      <span style=color:#a6e22e>cell</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>);
    }
  }
  <span style=color:#a6e22e>step</span>();
}

<span style=color:#75715e>// Draws a colored circle with interpolated hue
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>cell</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) {
  <span style=color:#a6e22e>fill</span>(<span style=color:#e6db74>`hsl(</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>i</span>,<span style=color:#ae81ff>0</span>,<span style=color:#a6e22e>size</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>360</span>))<span style=color:#e6db74>}</span><span style=color:#e6db74>,100%,50%)`</span>);
  <span style=color:#a6e22e>circle</span>(<span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>x</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>resolution</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>y</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>resolution</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>resolution</span>);
}
</code></pre></div><p>That is all, let&rsquo;s quickly review what is happening, first we <code>clear()</code> the canvas and fill it with black <code>background(0)</code> as we are only going to be drawing live cells (way more efficient). Next we proceed as usual, but check for live cells only <code>state[i] == live</code> (for readability as <code>state[i]</code> is already a boolean). Now the magic happens, we need to scale both <code>x</code> and <code>y</code> back to screen coordinates by multiplying them by the resolution, and in <code>cell(i, x, y)</code> we set the <code>fill(color)</code> with a neat trick by interpolating <code>i</code> into the hue [0, 360) of an <code>HSL</code> color! And finally we draw our cell as a colored <code>circle(x, y, radius)</code> with an offset to center it. Let&rsquo;s see it in action! üòé</p><div class=sketch><div class=sketch-toolbar><div class=sketch-title><span><i class="fa fa-fw fa-chevron-right" aria-hidden=true></i>&nbsp;Colorful Life</span></div><div class=sketch-controls><a class=controls href=https://github.com/phrozen/gestrada.dev/blob/main/content/posts/the-game-of-life/colorful-life.js target=_blank><i class="fa fa-fw fa-code" aria-hidden=true></i></a><a class=controls href=/sketches/colorful-life target=_blank><i class="fa fa-fw fa-external-link" aria-hidden=true></i></a><a class=controls onclick='reload("p5-colorful-life")'><i class="fa fa-fw fa-refresh" aria-hidden=true></i></a></div></div><div class=sketch-container><iframe id=p5-colorful-life class=sketch-iframe sandbox="allow-scripts allow-same-origin" srcdoc="
  <!DOCTYPE html>
<html>
    <head>
        <style>
            html, body {
                width: 100%;
                border: 0;
                padding: 0;
                margin: 0;
            }
            main, .p5Canvas {
                width: 100% !important;
                height: auto !important;
                max-width: 860px;
                display: block;
                image-rendering: pixelated;
            }
        </style>
        <script src=&#34;https://cdn.jsdelivr.net/npm/p5@latest/lib/p5.min.js&#34;></script>
    </head>
    <body>
        <script>
            
    let size;               // width * height (readability)
let state, next;        // current and nex generation
let percentage = 25;    // ~% of live cells to seed
let live = true;        // Use booleans as we don't need to store
let dead = false;       // the color, it's calculated on draw
let offset;             // hold the adjacent offsets of neighbours
let resolution = 10;    // to create a virtual grid on top the canvas
let half;               // readability (resolution / 2)

function setup() {
    createCanvas(1280, 720);
    frameRate(15);
    noStroke();
    width = width / resolution;
    height = height / resolution;
    size = width * height;
    half = resolution / 2;
    state = Array(size).fill(dead);
    next = Array(size).fill(dead);
    offset = [ // offsets for neighbours in 1D array
        -width - 1, // nw
        -width, // n
        -width + 1, // ne
        1, // e
        width + 1, // se
        width, // s
        width - 1, // sw
        -1, // w
    ];
    seed();
}

// Main rendering loop
function draw() {
    if (mouseIsPressed === true) {
        let i = floor(mouseY / resolution) * width + floor(mouseX / resolution);
        state[i] = live;
        cell(i, mouseX, mouseY);
        return;
    }

    clear();
    background(0);
    for (let i = 0; i < size; i++) {
        if (state[i]) {
            let x = (i % width) * resolution;
            let y = (i / width) * resolution;
            cell(i, x, y);
        }
    }
    step();
}

// Draws a colored circle with interpolated hue
function cell(i, x, y) {
    fill(`hsl(${floor(map(i,0,size,0,360))},100%,50%)`);
    circle(floor(x) + half, floor(y) + half, resolution);
}

// Randomly seeds the state with live cells
function seed() {
    state.fill(dead);
    const living = floor(size * percentage / 100);
    for (let i = 0; i < living; i++) {
        state[floor(random(size))] = live;
    }
}

// Creates the next generation of cells
function step() {
    for (let i = 0; i < size; i++) {
        let neighbours = 0;
        for (let j of offset) {
            neighbours += at(i + j);
        }
        if ((state[i] == live) && (neighbours < 2 || neighbours > 3)) next[i] = dead;
        else if ((state[i] == dead) && (neighbours == 3)) next[i] = live;
        else next[i] = state[i];
    }
    let tmp = state;
    state = next;
    next = tmp;
}

// Gets cell 'status' at a given index (1D)
function at(i) {
    if (i < 0) i += size;
    if (i > size) i -= size;
    return state[i] == live ? 1 : 0;
}
  
        </script>
    </body>
</html>
" onload=resize(this) scrolling=no frameborder=0></iframe></div></div><p>Bravo! I separated <code>cell</code> into a new function to add a bit more fun to <em>The Game of Life</em>, now instead of re-seeding randomly by clicking on the canvas, it actually seeds new cells manually! Try it, just press the mouse button and draw some live cells directly to the current generation while it remains <code>paused</code>. Now it&rsquo;s way more fun to play with it. To achieve this, we simply modify <code>draw()</code> like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// Main rendering loop
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>mouseIsPressed</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>true</span>) {
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>mouseY</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>resolution</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>mouseX</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>resolution</span>);
    <span style=color:#a6e22e>state</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>live</span>;
    <span style=color:#a6e22e>cell</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>mouseX</span>, <span style=color:#a6e22e>mouseY</span>);
    <span style=color:#66d9ef>return</span>;
  }
  <span style=color:#75715e>// ...rest of draw function  
</span><span style=color:#75715e></span>}
</code></pre></div><h4 id=closing-thoughts>Closing thoughts
<a class=heading-link href=#closing-thoughts><i class="fa fa-link" aria-hidden=true></i></a></h4><p>And that&rsquo;s all for today. You can keep learning <a href=https://p5js.org/>p5.js</a> using it&rsquo;s <a href=https://editor.p5js.org/>web editor</a> for your own sketches! Play with <em>The Game of Life</em> on the sketch above or <a href=https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life>learn more about it</a>! I really enjoyed writing <em>Life</em> as it&rsquo;s something I have never done before, and I will definitely keep on doing it! The main purpose of this blog is to document everything I learn about generative art, as well as to share everything I already know. In a later episode, let&rsquo;s do a similar implementation using Go (or Rust if I can manage to learn it before then), compile it into Web Assembly and make some benchmarks!</p><p>One thing that took some time was hacking p5.js so that I could embed sketches where the canvas scale with the content, so that they could be viewed within the post naturally without worrying about specific sizing of the canvas. This led me to write some <a href=https://gohugo.io/templates/shortcode-templates/>Hugo shortcodes</a> in order to generate minimal HTML files I could embed within my site, where I had full control over the style (you can check them out on Github). I would like to keep using p5.js in my posts on a regular basis, as it&rsquo;s awesome for drafting some code and producing amazing results, so it is most likely I will write my own minimal editor that I can embed into the blog with JS. I will be using <a href=https://svelte.dev/>Svelte</a> and going the same route as the official editor by hacking away with the <a href=https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe>iframe&rsquo;s srcdoc attribute</a>, that way I can provide fine controls (play, stop, refresh, edit, fullscreen, etc&mldr;) and I&rsquo;ll make sure it&rsquo;s open source. If it sounds like something you might be interested in let me know in the comments!</p><p>¬°Hasta la pr√≥xima!</p><a href=https://github.com/phrozen/gestrada.dev><img src=https://img.shields.io/badge/Code-Check%20me%20on%20Github!-brightgreen alt="Check me on Github!" title="Check me on Github!"></a></div><footer><section class=see-also></section><script src=https://utteranc.es/client.js repo=phrozen/gestrada.dev issue-term=pathname label=Label theme=preferred-color-scheme crossorigin=anonymous async></script></footer></article></section></div><footer class=footer><section class=container><p>Daydreamer, analytical brainiac, shameless romantic, factual magician, practical poet, irrational empath, generative artist, ninja coder and mind reader.</p>¬©
2021
Guillermo Estrada
¬∑
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/dark-mode.min.aee9c8a464eb7b3534c7110f7c5e169e7039e2fd92710e0626d451d6725af137.js></script><script src=/js/sketch.js></script><script data-goatcounter=https://gestrada.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>